`timescale 1ns/1ps

module BOOTH (
  input lda, ldq, ldm, clra, clrq, clrff, sfta, sftq, addsub, decr, ldcnt,
  input signed [15:0] data_in,
  input clk,
  output qm1, eqz,
  output logic signed [31:0] product
);
  wire signed [15:0] a, m, q, z;
  wire [4:0] count;

  assign eqz = ~|count;
  assign product = {a, q};

  shiftreg AR (.data_out(a), .data_in(z), .s_in(a[15]), .clk(clk), .ld(lda), .clr(clra), .sft(sfta));
  shiftreg QR (.data_out(q), .data_in(data_in), .s_in(a[0]), .clk(clk), .ld(ldq), .clr(clrq), .sft(sftq));
  dff QM1 (.d(q[0]), .q(qm1), .clk(clk), .clr(clrff));
  PIPO MR (.data_out(m), .data_in(data_in), .clk(clk), .load(ldm));
  ALU AS (.out(z), .in1(a), .in2(m), .addsub(addsub));
  counter CN (.data_out(count), .decr(decr), .ldcnt(ldcnt), .clk(clk));
endmodule

module shiftreg (
  output reg signed [15:0] data_out,
  input signed [15:0] data_in,
  input s_in, clk, ld, clr, sft
);
  always @(posedge clk) begin
    if (clr) data_out <= 0;
    else if (ld) data_out <= data_in;
    else if (sft) data_out <= {s_in, data_out[15:1]};
  end
endmodule

module PIPO (
  output reg signed [15:0] data_out,
  input signed [15:0] data_in,
  input clk, load
);
  always @(posedge clk)
    if (load) data_out <= data_in;
endmodule

module dff (
  input d, clk, clr,
  output reg q
);
  always @(posedge clk)
    if (clr) q <= 0;
    else q <= d;
endmodule

module ALU (
  output reg signed [15:0] out,
  input signed [15:0] in1, in2,
  input addsub
);
  always @(*) begin
    if (addsub == 0) out = in1 - in2;
    else out = in1 + in2;
  end
endmodule

module counter (
  output reg [4:0] data_out,
  input decr, ldcnt, clk
);
  always @(posedge clk) begin
    if (ldcnt) data_out <= 5'd16;
    else if (decr) data_out <= data_out - 1;
  end
endmodule

module controller (
  output reg lda, clra, sfta, ldq, clrq, sftq,
  output reg ldm, clrff, addsub, decr, ldcnt, done,
  input clk, q0, qm1, start, eqz
);
  reg [2:0] state;
  parameter S0=3'b000, S1=3'b001, S2=3'b010, S3=3'b011,
            S4=3'b100, S5=3'b101, S6=3'b110;

  always @(posedge clk) begin
    case(state)
      S0 : if (start) state <= S1;
      S1 : state <= S2;
      S2 : if ({q0, qm1} == 2'b01) state <= S3;
           else if ({q0, qm1} == 2'b10) state <= S4;
           else state <= S5;
      S3 : state <= S5;
      S4 : state <= S5;
      S5 : if (!eqz && ({q0, qm1} == 2'b01)) state <= S3;
           else if (!eqz && ({q0, qm1} == 2'b10)) state <= S4;
           else if (eqz) state <= S6;
      S6 : state <= S6;
      default : state <= S0;
    endcase
  end

  always @(*) begin
    lda=0; clra=0; sfta=0; ldq=0; clrq=0; sftq=0;
    ldm=0; clrff=0; addsub=0; decr=0; ldcnt=0; done=0;

    case (state)
      S1 : begin clra=1; clrff=1; ldcnt=1; ldm=1; end
      S2 : begin ldq=1; end
      S3 : begin lda=1; addsub=1; end
      S4 : begin lda=1; addsub=0; end
      S5 : begin sfta=1; sftq=1; decr=1; end
      S6 : begin done=1; end
    endcase
  end
endmodule
